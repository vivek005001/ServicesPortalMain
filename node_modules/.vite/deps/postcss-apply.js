import {
  __commonJS,
  __toESM
} from "./chunk-LQ2VYIYD.js";

// ../../../node_modules/postcss-apply/node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/picocolors/picocolors.browser.js"(exports, module) {
    var x = String;
    var create = function() {
      return { isColorSupported: false, reset: x, bold: x, dim: x, italic: x, underline: x, inverse: x, hidden: x, strikethrough: x, black: x, red: x, green: x, yellow: x, blue: x, magenta: x, cyan: x, white: x, gray: x, bgBlack: x, bgRed: x, bgGreen: x, bgYellow: x, bgBlue: x, bgMagenta: x, bgCyan: x, bgWhite: x };
    };
    module.exports = create();
    module.exports.createColors = create;
  }
});

// (disabled):../../../node_modules/postcss-apply/node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):../../../node_modules/postcss-apply/node_modules/postcss/lib/terminal-highlight"() {
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/css-syntax-error.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _picocolors = _interopRequireDefault(require_picocolors_browser());
    var _terminalHighlight = _interopRequireDefault(require_terminal_highlight());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var CssSyntaxError = function(_Error) {
      _inheritsLoose(CssSyntaxError2, _Error);
      function CssSyntaxError2(message, line, column, source, file, plugin2) {
        var _this;
        _this = _Error.call(this, message) || this;
        _this.name = "CssSyntaxError";
        _this.reason = message;
        if (file) {
          _this.file = file;
        }
        if (source) {
          _this.source = source;
        }
        if (plugin2) {
          _this.plugin = plugin2;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          _this.line = line;
          _this.column = column;
        }
        _this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), CssSyntaxError2);
        }
        return _this;
      }
      var _proto = CssSyntaxError2.prototype;
      _proto.setMessage = function setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      };
      _proto.showSourceCode = function showSourceCode(color) {
        var _this2 = this;
        if (!this.source)
          return "";
        var css = this.source;
        if (_terminalHighlight.default) {
          if (typeof color === "undefined")
            color = _picocolors.default.isColorSupported;
          if (color)
            css = (0, _terminalHighlight.default)(css);
        }
        var lines = css.split(/\r?\n/);
        var start = Math.max(this.line - 3, 0);
        var end = Math.min(this.line + 2, lines.length);
        var maxWidth = String(end).length;
        function mark(text) {
          if (color && _picocolors.default.red) {
            return _picocolors.default.red(_picocolors.default.bold(text));
          }
          return text;
        }
        function aside(text) {
          if (color && _picocolors.default.gray) {
            return _picocolors.default.gray(text);
          }
          return text;
        }
        return lines.slice(start, end).map(function(line, index2) {
          var number = start + 1 + index2;
          var gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === _this2.line) {
            var spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, _this2.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      };
      _proto.toString = function toString() {
        var code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      };
      return CssSyntaxError2;
    }(_wrapNativeSuper(Error));
    var _default = CssSyntaxError;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/stringifier.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var DEFAULT_RAW = {
      colon: ": ",
      indent: "    ",
      beforeDecl: "\n",
      beforeRule: "\n",
      beforeOpen: " ",
      beforeClose: "\n",
      beforeComment: "\n",
      after: "\n",
      emptyBody: "",
      commentLeft: " ",
      commentRight: " ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = function() {
      function Stringifier2(builder) {
        this.builder = builder;
      }
      var _proto = Stringifier2.prototype;
      _proto.stringify = function stringify(node, semicolon) {
        this[node.type](node, semicolon);
      };
      _proto.root = function root(node) {
        this.body(node);
        if (node.raws.after)
          this.builder(node.raws.after);
      };
      _proto.comment = function comment(node) {
        var left = this.raw(node, "left", "commentLeft");
        var right = this.raw(node, "right", "commentRight");
        this.builder("/*" + left + node.text + right + "*/", node);
      };
      _proto.decl = function decl(node, semicolon) {
        var between = this.raw(node, "between", "colon");
        var string = node.prop + between + this.rawValue(node, "value");
        if (node.important) {
          string += node.raws.important || " !important";
        }
        if (semicolon)
          string += ";";
        this.builder(string, node);
      };
      _proto.rule = function rule(node) {
        this.block(node, this.rawValue(node, "selector"));
        if (node.raws.ownSemicolon) {
          this.builder(node.raws.ownSemicolon, node, "end");
        }
      };
      _proto.atrule = function atrule(node, semicolon) {
        var name2 = "@" + node.name;
        var params = node.params ? this.rawValue(node, "params") : "";
        if (typeof node.raws.afterName !== "undefined") {
          name2 += node.raws.afterName;
        } else if (params) {
          name2 += " ";
        }
        if (node.nodes) {
          this.block(node, name2 + params);
        } else {
          var end = (node.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name2 + params + end, node);
        }
      };
      _proto.body = function body(node) {
        var last = node.nodes.length - 1;
        while (last > 0) {
          if (node.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        var semicolon = this.raw(node, "semicolon");
        for (var i = 0; i < node.nodes.length; i++) {
          var child = node.nodes[i];
          var before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i || semicolon);
        }
      };
      _proto.block = function block(node, start) {
        var between = this.raw(node, "between", "beforeOpen");
        this.builder(start + between + "{", node, "start");
        var after;
        if (node.nodes && node.nodes.length) {
          this.body(node);
          after = this.raw(node, "after");
        } else {
          after = this.raw(node, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node, "end");
      };
      _proto.raw = function raw(node, own, detect) {
        var value;
        if (!detect)
          detect = own;
        if (own) {
          value = node.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        var parent = node.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node) {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        var root = node.root();
        if (!root.rawCache)
          root.rawCache = {};
        if (typeof root.rawCache[detect] !== "undefined") {
          return root.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node, detect);
        } else {
          var method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node);
          } else {
            root.walk(function(i) {
              value = i.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        return value;
      };
      _proto.rawSemicolon = function rawSemicolon(root) {
        var value;
        root.walk(function(i) {
          if (i.nodes && i.nodes.length && i.last.type === "decl") {
            value = i.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      };
      _proto.rawEmptyBody = function rawEmptyBody(root) {
        var value;
        root.walk(function(i) {
          if (i.nodes && i.nodes.length === 0) {
            value = i.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      };
      _proto.rawIndent = function rawIndent(root) {
        if (root.raws.indent)
          return root.raws.indent;
        var value;
        root.walk(function(i) {
          var p = i.parent;
          if (p && p !== root && p.parent && p.parent === root) {
            if (typeof i.raws.before !== "undefined") {
              var parts = i.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/[^\s]/g, "");
              return false;
            }
          }
        });
        return value;
      };
      _proto.rawBeforeComment = function rawBeforeComment(root, node) {
        var value;
        root.walkComments(function(i) {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.indexOf("\n") !== -1) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/[^\s]/g, "");
        }
        return value;
      };
      _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {
        var value;
        root.walkDecls(function(i) {
          if (typeof i.raws.before !== "undefined") {
            value = i.raws.before;
            if (value.indexOf("\n") !== -1) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node, null, "beforeRule");
        } else if (value) {
          value = value.replace(/[^\s]/g, "");
        }
        return value;
      };
      _proto.rawBeforeRule = function rawBeforeRule(root) {
        var value;
        root.walk(function(i) {
          if (i.nodes && (i.parent !== root || root.first !== i)) {
            if (typeof i.raws.before !== "undefined") {
              value = i.raws.before;
              if (value.indexOf("\n") !== -1) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/[^\s]/g, "");
        return value;
      };
      _proto.rawBeforeClose = function rawBeforeClose(root) {
        var value;
        root.walk(function(i) {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== "undefined") {
              value = i.raws.after;
              if (value.indexOf("\n") !== -1) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/[^\s]/g, "");
        return value;
      };
      _proto.rawBeforeOpen = function rawBeforeOpen(root) {
        var value;
        root.walk(function(i) {
          if (i.type !== "decl") {
            value = i.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      };
      _proto.rawColon = function rawColon(root) {
        var value;
        root.walkDecls(function(i) {
          if (typeof i.raws.between !== "undefined") {
            value = i.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      };
      _proto.beforeAfter = function beforeAfter(node, detect) {
        var value;
        if (node.type === "decl") {
          value = this.raw(node, null, "beforeDecl");
        } else if (node.type === "comment") {
          value = this.raw(node, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node, null, "beforeRule");
        } else {
          value = this.raw(node, null, "beforeClose");
        }
        var buf = node.parent;
        var depth = 0;
        while (buf && buf.type !== "root") {
          depth += 1;
          buf = buf.parent;
        }
        if (value.indexOf("\n") !== -1) {
          var indent = this.raw(node, null, "indent");
          if (indent.length) {
            for (var step = 0; step < depth; step++) {
              value += indent;
            }
          }
        }
        return value;
      };
      _proto.rawValue = function rawValue(node, prop) {
        var value = node[prop];
        var raw = node.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      };
      return Stringifier2;
    }();
    var _default = Stringifier;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/stringify.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _stringifier = _interopRequireDefault(require_stringifier());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringify(node, builder) {
      var str = new _stringifier.default(builder);
      str.stringify(node);
    }
    var _default = stringify;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/node.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _cssSyntaxError = _interopRequireDefault(require_css_syntax_error());
    var _stringifier = _interopRequireDefault(require_stringifier());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function cloneNode(obj, parent) {
      var cloned = new obj.constructor();
      for (var i in obj) {
        if (!obj.hasOwnProperty(i))
          continue;
        var value = obj[i];
        var type = typeof value;
        if (i === "parent" && type === "object") {
          if (parent)
            cloned[i] = parent;
        } else if (i === "source") {
          cloned[i] = value;
        } else if (value instanceof Array) {
          cloned[i] = value.map(function(j) {
            return cloneNode(j, cloned);
          });
        } else {
          if (type === "object" && value !== null)
            value = cloneNode(value);
          cloned[i] = value;
        }
      }
      return cloned;
    }
    var Node = function() {
      function Node2(defaults) {
        if (defaults === void 0) {
          defaults = {};
        }
        this.raws = {};
        if (true) {
          if (typeof defaults !== "object" && typeof defaults !== "undefined") {
            throw new Error("PostCSS nodes constructor accepts object, not " + JSON.stringify(defaults));
          }
        }
        for (var name2 in defaults) {
          this[name2] = defaults[name2];
        }
      }
      var _proto = Node2.prototype;
      _proto.error = function error(message, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (this.source) {
          var pos = this.positionBy(opts);
          return this.source.input.error(message, pos.line, pos.column, opts);
        }
        return new _cssSyntaxError.default(message);
      };
      _proto.warn = function warn(result, text, opts) {
        var data = {
          node: this
        };
        for (var i in opts) {
          data[i] = opts[i];
        }
        return result.warn(text, data);
      };
      _proto.remove = function remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      };
      _proto.toString = function toString(stringifier) {
        if (stringifier === void 0) {
          stringifier = _stringify.default;
        }
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        var result = "";
        stringifier(this, function(i) {
          result += i;
        });
        return result;
      };
      _proto.clone = function clone(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = cloneNode(this);
        for (var name2 in overrides) {
          cloned[name2] = overrides[name2];
        }
        return cloned;
      };
      _proto.cloneBefore = function cloneBefore(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      };
      _proto.cloneAfter = function cloneAfter(overrides) {
        if (overrides === void 0) {
          overrides = {};
        }
        var cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      };
      _proto.replaceWith = function replaceWith() {
        if (this.parent) {
          for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
            nodes[_key] = arguments[_key];
          }
          for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
            var node = _nodes[_i];
            this.parent.insertBefore(this, node);
          }
          this.remove();
        }
        return this;
      };
      _proto.next = function next() {
        if (!this.parent)
          return void 0;
        var index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      };
      _proto.prev = function prev() {
        if (!this.parent)
          return void 0;
        var index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      };
      _proto.before = function before(add) {
        this.parent.insertBefore(this, add);
        return this;
      };
      _proto.after = function after(add) {
        this.parent.insertAfter(this, add);
        return this;
      };
      _proto.toJSON = function toJSON() {
        var fixed = {};
        for (var name2 in this) {
          if (!this.hasOwnProperty(name2))
            continue;
          if (name2 === "parent")
            continue;
          var value = this[name2];
          if (value instanceof Array) {
            fixed[name2] = value.map(function(i) {
              if (typeof i === "object" && i.toJSON) {
                return i.toJSON();
              } else {
                return i;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name2] = value.toJSON();
          } else {
            fixed[name2] = value;
          }
        }
        return fixed;
      };
      _proto.raw = function raw(prop, defaultType) {
        var str = new _stringifier.default();
        return str.raw(this, prop, defaultType);
      };
      _proto.root = function root() {
        var result = this;
        while (result.parent) {
          result = result.parent;
        }
        return result;
      };
      _proto.cleanRaws = function cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      };
      _proto.positionInside = function positionInside(index2) {
        var string = this.toString();
        var column = this.source.start.column;
        var line = this.source.start.line;
        for (var i = 0; i < index2; i++) {
          if (string[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return {
          line,
          column
        };
      };
      _proto.positionBy = function positionBy(opts) {
        var pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index);
        } else if (opts.word) {
          var index2 = this.toString().indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2);
        }
        return pos;
      };
      return Node2;
    }();
    var _default = Node;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/declaration.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _node = _interopRequireDefault(require_node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var Declaration = function(_Node) {
      _inheritsLoose(Declaration2, _Node);
      function Declaration2(defaults) {
        var _this;
        _this = _Node.call(this, defaults) || this;
        _this.type = "decl";
        return _this;
      }
      return Declaration2;
    }(_node.default);
    var _default = Declaration;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../../../node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../../../node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../../../node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// ../../../node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../../../node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// ../../../node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../../../node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// ../../../node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../../../node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// ../../../node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../../../node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name2 = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name2);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name2 != null) {
        name2 = String(name2);
        if (!this._names.has(name2)) {
          this._names.add(name2);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name: name2
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name2 = mapping.name;
        if (name2 != null && !newNames.has(name2)) {
          newNames.add(name2);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../../../node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../../../node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  }
});

// ../../../node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../../../node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../../../node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../../../node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c = aStr.charAt(index2);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index2 < length) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = cachedSegments[str];
          if (segment) {
            index2 += str.length;
          } else {
            segment = [];
            while (index2 < end) {
              base64VLQ.decode(aStr, index2, temp);
              value = temp.value;
              index2 = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name2 = util.getArg(mapping, "name", null);
          if (name2 !== null) {
            name2 = this._names.at(name2);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name: name2
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name2 = null;
          if (mapping.name) {
            name2 = section.consumer._names.at(mapping.name);
            this._names.add(name2);
            name2 = this._names.indexOf(name2);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name2
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../../../node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../../../node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// ../../../node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../../../node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/map-generator.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _sourceMap = _interopRequireDefault(require_source_map());
    var _path = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var MapGenerator = function() {
      function MapGenerator2(stringify, root, opts) {
        this.stringify = stringify;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
      }
      var _proto = MapGenerator2.prototype;
      _proto.isMap = function isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      };
      _proto.previous = function previous() {
        var _this = this;
        if (!this.previousMaps) {
          this.previousMaps = [];
          this.root.walk(function(node) {
            if (node.source && node.source.input.map) {
              var map = node.source.input.map;
              if (_this.previousMaps.indexOf(map) === -1) {
                _this.previousMaps.push(map);
              }
            }
          });
        }
        return this.previousMaps;
      };
      _proto.isInline = function isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        var annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some(function(i) {
            return i.inline;
          });
        }
        return true;
      };
      _proto.isSourcesContent = function isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some(function(i) {
            return i.withContent();
          });
        }
        return true;
      };
      _proto.clearAnnotation = function clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        var node;
        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
          node = this.root.nodes[i];
          if (node.type !== "comment")
            continue;
          if (node.text.indexOf("# sourceMappingURL=") === 0) {
            this.root.removeChild(i);
          }
        }
      };
      _proto.setSourcesContent = function setSourcesContent() {
        var _this2 = this;
        var already = {};
        this.root.walk(function(node) {
          if (node.source) {
            var from = node.source.input.from;
            if (from && !already[from]) {
              already[from] = true;
              var relative = _this2.relative(from);
              _this2.map.setSourceContent(relative, node.source.input.css);
            }
          }
        });
      };
      _proto.applyPrevMaps = function applyPrevMaps() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.previous()), _step; !(_step = _iterator()).done; ) {
          var prev = _step.value;
          var from = this.relative(prev.file);
          var root = prev.root || _path.default.dirname(prev.file);
          var map = void 0;
          if (this.mapOpts.sourcesContent === false) {
            map = new _sourceMap.default.SourceMapConsumer(prev.text);
            if (map.sourcesContent) {
              map.sourcesContent = map.sourcesContent.map(function() {
                return null;
              });
            }
          } else {
            map = prev.consumer();
          }
          this.map.applySourceMap(map, from, this.relative(root));
        }
      };
      _proto.isAnnotation = function isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some(function(i) {
            return i.annotation;
          });
        }
        return true;
      };
      _proto.toBase64 = function toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        }
        return window.btoa(unescape(encodeURIComponent(str)));
      };
      _proto.addAnnotation = function addAnnotation() {
        var content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else {
          content = this.outputFile() + ".map";
        }
        var eol = "\n";
        if (this.css.indexOf("\r\n") !== -1)
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      };
      _proto.outputFile = function outputFile() {
        if (this.opts.to) {
          return this.relative(this.opts.to);
        }
        if (this.opts.from) {
          return this.relative(this.opts.from);
        }
        return "to.css";
      };
      _proto.generateMap = function generateMap() {
        this.generateString();
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        }
        return [this.css, this.map];
      };
      _proto.relative = function relative(file) {
        if (file.indexOf("<") === 0)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        var from = this.opts.to ? _path.default.dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));
        }
        file = _path.default.relative(from, file);
        if (_path.default.sep === "\\") {
          return file.replace(/\\/g, "/");
        }
        return file;
      };
      _proto.sourcePath = function sourcePath(node) {
        if (this.mapOpts.from) {
          return this.mapOpts.from;
        }
        return this.relative(node.source.input.from);
      };
      _proto.generateString = function generateString() {
        var _this3 = this;
        this.css = "";
        this.map = new _sourceMap.default.SourceMapGenerator({
          file: this.outputFile()
        });
        var line = 1;
        var column = 1;
        var lines, last;
        this.stringify(this.root, function(str, node, type) {
          _this3.css += str;
          if (node && type !== "end") {
            if (node.source && node.source.start) {
              _this3.map.addMapping({
                source: _this3.sourcePath(node),
                generated: {
                  line,
                  column: column - 1
                },
                original: {
                  line: node.source.start.line,
                  column: node.source.start.column - 1
                }
              });
            } else {
              _this3.map.addMapping({
                source: "<no source>",
                original: {
                  line: 1,
                  column: 0
                },
                generated: {
                  line,
                  column: column - 1
                }
              });
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node && type !== "start") {
            var p = node.parent || {
              raws: {}
            };
            if (node.type !== "decl" || node !== p.last || p.raws.semicolon) {
              if (node.source && node.source.end) {
                _this3.map.addMapping({
                  source: _this3.sourcePath(node),
                  generated: {
                    line,
                    column: column - 2
                  },
                  original: {
                    line: node.source.end.line,
                    column: node.source.end.column - 1
                  }
                });
              } else {
                _this3.map.addMapping({
                  source: "<no source>",
                  original: {
                    line: 1,
                    column: 0
                  },
                  generated: {
                    line,
                    column: column - 1
                  }
                });
              }
            }
          }
        });
      };
      _proto.generate = function generate() {
        this.clearAnnotation();
        if (this.isMap()) {
          return this.generateMap();
        }
        var result = "";
        this.stringify(this.root, function(i) {
          result += i;
        });
        return [result];
      };
      return MapGenerator2;
    }();
    var _default = MapGenerator;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/warn-once.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = warnOnce;
    var printed = {};
    function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    }
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/warning.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var Warning = function() {
      function Warning2(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          var pos = opts.node.positionBy(opts);
          this.line = pos.line;
          this.column = pos.column;
        }
        for (var opt in opts) {
          this[opt] = opts[opt];
        }
      }
      var _proto = Warning2.prototype;
      _proto.toString = function toString() {
        if (this.node) {
          return this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      };
      return Warning2;
    }();
    var _default = Warning;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/result.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _warning = _interopRequireDefault(require_warning());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Result = function() {
      function Result2(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      var _proto = Result2.prototype;
      _proto.toString = function toString() {
        return this.css;
      };
      _proto.warn = function warn(text, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        var warning = new _warning.default(text, opts);
        this.messages.push(warning);
        return warning;
      };
      _proto.warnings = function warnings() {
        return this.messages.filter(function(i) {
          return i.type === "warning";
        });
      };
      _createClass(Result2, [{
        key: "content",
        get: function get() {
          return this.css;
        }
      }]);
      return Result2;
    }();
    var _default = Result;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/tokenize.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = tokenizer;
    var SINGLE_QUOTE = "'".charCodeAt(0);
    var DOUBLE_QUOTE = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[ \n\t\r\f{}()'"\\;/[\]#]/g;
    var RE_WORD_END = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\\/("'\n]/;
    var RE_HEX_ESCAPE = /[a-f0-9]/i;
    function tokenizer(input, options) {
      if (options === void 0) {
        options = {};
      }
      var css = input.css.valueOf();
      var ignore = options.ignoreErrors;
      var code, next, quote, lines, last, content, escape;
      var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;
      var length = css.length;
      var offset = -1;
      var line = 1;
      var pos = 0;
      var buffer = [];
      var returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, line, pos - offset);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {
          offset = pos;
          line += 1;
        }
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED:
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
              if (code === NEWLINE) {
                offset = next;
                line += 1;
              }
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON:
          case SEMICOLON:
          case CLOSE_PARENTHESES:
            var controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, line, pos - offset];
            break;
          case OPEN_PARENTHESES:
            prev = buffer.length ? buffer.pop()[1] : "";
            n = css.charCodeAt(pos + 1);
            if (prev === "url" && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
              next = pos;
              do {
                escaped = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["brackets", css.slice(pos, next + 1), line, pos - offset, line, next - offset];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", line, pos - offset];
              } else {
                currentToken = ["brackets", content, line, pos - offset, line, next - offset];
                pos = next;
              }
            }
            break;
          case SINGLE_QUOTE:
          case DOUBLE_QUOTE:
            quote = code === SINGLE_QUOTE ? "'" : '"';
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            content = css.slice(pos, next + 1);
            lines = content.split("\n");
            last = lines.length - 1;
            if (last > 0) {
              nextLine = line + last;
              nextOffset = next - lines[last].length;
            } else {
              nextLine = line;
              nextOffset = offset;
            }
            currentToken = ["string", css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];
            offset = nextOffset;
            line = nextLine;
            pos = next;
            break;
          case AT:
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), line, pos - offset, line, next - offset];
            pos = next;
            break;
          case BACKSLASH:
            next = pos;
            escape = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape = !escape;
            }
            code = css.charCodeAt(next + 1);
            if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), line, pos - offset, line, next - offset];
            pos = next;
            break;
          default:
            if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              content = css.slice(pos, next + 1);
              lines = content.split("\n");
              last = lines.length - 1;
              if (last > 0) {
                nextLine = line + last;
                nextOffset = next - lines[last].length;
              } else {
                nextLine = line;
                nextOffset = offset;
              }
              currentToken = ["comment", content, line, pos - offset, nextLine, next - nextOffset];
              offset = nextOffset;
              line = nextLine;
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), line, pos - offset, line, next - offset];
              buffer.push(currentToken);
              pos = next;
            }
            break;
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        nextToken,
        endOfFile,
        position
      };
    }
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/comment.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _node = _interopRequireDefault(require_node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var Comment = function(_Node) {
      _inheritsLoose(Comment2, _Node);
      function Comment2(defaults) {
        var _this;
        _this = _Node.call(this, defaults) || this;
        _this.type = "comment";
        return _this;
      }
      return Comment2;
    }(_node.default);
    var _default = Comment;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/list.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var list = {
      split: function split(string, separators, last) {
        var array = [];
        var current = "";
        var split2 = false;
        var func = 0;
        var quote = false;
        var escape = false;
        for (var i = 0; i < string.length; i++) {
          var letter = string[i];
          if (quote) {
            if (escape) {
              escape = false;
            } else if (letter === "\\") {
              escape = true;
            } else if (letter === quote) {
              quote = false;
            }
          } else if (letter === '"' || letter === "'") {
            quote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.indexOf(letter) !== -1)
              split2 = true;
          }
          if (split2) {
            if (current !== "")
              array.push(current.trim());
            current = "";
            split2 = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array.push(current.trim());
        return array;
      },
      /**
       * Safely splits space-separated values (such as those for `background`,
       * `border-radius`, and other shorthand properties).
       *
       * @param {string} string Space-separated values.
       *
       * @return {string[]} Split values.
       *
       * @example
       * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
       */
      space: function space(string) {
        var spaces = [" ", "\n", "	"];
        return list.split(string, spaces);
      },
      /**
       * Safely splits comma-separated values (such as those for `transition-*`
       * and `background` properties).
       *
       * @param {string} string Comma-separated values.
       *
       * @return {string[]} Split values.
       *
       * @example
       * postcss.list.comma('black, linear-gradient(white, black)')
       * //=> ['black', 'linear-gradient(white, black)']
       */
      comma: function comma(string) {
        return list.split(string, [","], true);
      }
    };
    var _default = list;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/rule.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _container = _interopRequireDefault(require_container());
    var _list = _interopRequireDefault(require_list());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var Rule = function(_Container) {
      _inheritsLoose(Rule2, _Container);
      function Rule2(defaults) {
        var _this;
        _this = _Container.call(this, defaults) || this;
        _this.type = "rule";
        if (!_this.nodes)
          _this.nodes = [];
        return _this;
      }
      _createClass(Rule2, [{
        key: "selectors",
        get: function get() {
          return _list.default.comma(this.selector);
        },
        set: function set(values) {
          var match = this.selector ? this.selector.match(/,\s*/) : null;
          var sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep);
        }
        /**
         * @memberof Rule#
         * @member {string} selector The rules full selector represented
         *                           as a string.
         *
         * @example
         * const root = postcss.parse('a, b { }')
         * const rule = root.first
         * rule.selector //=> 'a, b'
         */
        /**
         * @memberof Rule#
         * @member {object} raws Information to generate byte-to-byte equal
         *                       node string as it was in the origin input.
         *
         * Every parser saves its own properties,
         * but the default CSS parser uses:
         *
         * * `before`: the space symbols before the node. It also stores `*`
         *   and `_` symbols before the declaration (IE hack).
         * * `after`: the space symbols after the last child of the node
         *   to the end of the node.
         * * `between`: the symbols between the property and value
         *   for declarations, selector and `{` for rules, or last parameter
         *   and `{` for at-rules.
         * * `semicolon`: contains `true` if the last child has
         *   an (optional) semicolon.
         * * `ownSemicolon`: contains `true` if there is semicolon after rule.
         *
         * PostCSS cleans selectors from comments and extra spaces,
         * but it stores origin content in raws properties.
         * As such, if you dont change a declarations value,
         * PostCSS will use the raw value with comments.
         *
         * @example
         * const root = postcss.parse('a {\n  color:black\n}')
         * root.first.first.raws //=> { before: '', between: ' ', after: '\n' }
         */
      }]);
      return Rule2;
    }(_container.default);
    var _default = Rule;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/container.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _declaration = _interopRequireDefault(require_declaration());
    var _comment = _interopRequireDefault(require_comment());
    var _node = _interopRequireDefault(require_node());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    function cleanSource(nodes) {
      return nodes.map(function(i) {
        if (i.nodes)
          i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
      });
    }
    var Container = function(_Node) {
      _inheritsLoose(Container2, _Node);
      function Container2() {
        return _Node.apply(this, arguments) || this;
      }
      var _proto = Container2.prototype;
      _proto.push = function push(child) {
        child.parent = this;
        this.nodes.push(child);
        return this;
      };
      _proto.each = function each(callback) {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        var id = this.lastEach;
        this.indexes[id] = 0;
        if (!this.nodes)
          return void 0;
        var index2, result;
        while (this.indexes[id] < this.nodes.length) {
          index2 = this.indexes[id];
          result = callback(this.nodes[index2], index2);
          if (result === false)
            break;
          this.indexes[id] += 1;
        }
        delete this.indexes[id];
        return result;
      };
      _proto.walk = function walk(callback) {
        return this.each(function(child, i) {
          var result;
          try {
            result = callback(child, i);
          } catch (e) {
            e.postcssNode = child;
            if (e.stack && child.source && /\n\s{4}at /.test(e.stack)) {
              var s = child.source;
              e.stack = e.stack.replace(/\n\s{4}at /, "$&" + s.input.from + ":" + s.start.line + ":" + s.start.column + "$&");
            }
            throw e;
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      };
      _proto.walkDecls = function walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk(function(child, i) {
            if (child.type === "decl") {
              return callback(child, i);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk(function(child, i) {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i);
            }
          });
        }
        return this.walk(function(child, i) {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i);
          }
        });
      };
      _proto.walkRules = function walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk(function(child, i) {
            if (child.type === "rule") {
              return callback(child, i);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk(function(child, i) {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i);
            }
          });
        }
        return this.walk(function(child, i) {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i);
          }
        });
      };
      _proto.walkAtRules = function walkAtRules(name2, callback) {
        if (!callback) {
          callback = name2;
          return this.walk(function(child, i) {
            if (child.type === "atrule") {
              return callback(child, i);
            }
          });
        }
        if (name2 instanceof RegExp) {
          return this.walk(function(child, i) {
            if (child.type === "atrule" && name2.test(child.name)) {
              return callback(child, i);
            }
          });
        }
        return this.walk(function(child, i) {
          if (child.type === "atrule" && child.name === name2) {
            return callback(child, i);
          }
        });
      };
      _proto.walkComments = function walkComments(callback) {
        return this.walk(function(child, i) {
          if (child.type === "comment") {
            return callback(child, i);
          }
        });
      };
      _proto.append = function append() {
        for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
          children[_key] = arguments[_key];
        }
        for (var _i = 0, _children = children; _i < _children.length; _i++) {
          var child = _children[_i];
          var nodes = this.normalize(child, this.last);
          for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done; ) {
            var node = _step.value;
            this.nodes.push(node);
          }
        }
        return this;
      };
      _proto.prepend = function prepend() {
        for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          children[_key2] = arguments[_key2];
        }
        children = children.reverse();
        for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done; ) {
          var child = _step2.value;
          var nodes = this.normalize(child, this.first, "prepend").reverse();
          for (var _iterator3 = _createForOfIteratorHelperLoose(nodes), _step3; !(_step3 = _iterator3()).done; ) {
            var node = _step3.value;
            this.nodes.unshift(node);
          }
          for (var id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        return this;
      };
      _proto.cleanRaws = function cleanRaws(keepBetween) {
        _Node.prototype.cleanRaws.call(this, keepBetween);
        if (this.nodes) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(this.nodes), _step4; !(_step4 = _iterator4()).done; ) {
            var node = _step4.value;
            node.cleanRaws(keepBetween);
          }
        }
      };
      _proto.insertBefore = function insertBefore(exist, add) {
        exist = this.index(exist);
        var type = exist === 0 ? "prepend" : false;
        var nodes = this.normalize(add, this.nodes[exist], type).reverse();
        for (var _iterator5 = _createForOfIteratorHelperLoose(nodes), _step5; !(_step5 = _iterator5()).done; ) {
          var node = _step5.value;
          this.nodes.splice(exist, 0, node);
        }
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (exist <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        return this;
      };
      _proto.insertAfter = function insertAfter(exist, add) {
        exist = this.index(exist);
        var nodes = this.normalize(add, this.nodes[exist]).reverse();
        for (var _iterator6 = _createForOfIteratorHelperLoose(nodes), _step6; !(_step6 = _iterator6()).done; ) {
          var node = _step6.value;
          this.nodes.splice(exist + 1, 0, node);
        }
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (exist < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        return this;
      };
      _proto.removeChild = function removeChild(child) {
        child = this.index(child);
        this.nodes[child].parent = void 0;
        this.nodes.splice(child, 1);
        var index2;
        for (var id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        return this;
      };
      _proto.removeAll = function removeAll() {
        for (var _iterator7 = _createForOfIteratorHelperLoose(this.nodes), _step7; !(_step7 = _iterator7()).done; ) {
          var node = _step7.value;
          node.parent = void 0;
        }
        this.nodes = [];
        return this;
      };
      _proto.replaceValues = function replaceValues(pattern, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls(function(decl) {
          if (opts.props && opts.props.indexOf(decl.prop) === -1)
            return;
          if (opts.fast && decl.value.indexOf(opts.fast) === -1)
            return;
          decl.value = decl.value.replace(pattern, callback);
        });
        return this;
      };
      _proto.every = function every(condition) {
        return this.nodes.every(condition);
      };
      _proto.some = function some(condition) {
        return this.nodes.some(condition);
      };
      _proto.index = function index2(child) {
        if (typeof child === "number") {
          return child;
        }
        return this.nodes.indexOf(child);
      };
      _proto.normalize = function normalize(nodes, sample) {
        var _this = this;
        if (typeof nodes === "string") {
          var parse = require_parse();
          nodes = cleanSource(parse(nodes).nodes);
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (var _iterator8 = _createForOfIteratorHelperLoose(nodes), _step8; !(_step8 = _iterator8()).done; ) {
            var i = _step8.value;
            if (i.parent)
              i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type === "root") {
          nodes = nodes.nodes.slice(0);
          for (var _iterator9 = _createForOfIteratorHelperLoose(nodes), _step9; !(_step9 = _iterator9()).done; ) {
            var _i2 = _step9.value;
            if (_i2.parent)
              _i2.parent.removeChild(_i2, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new _declaration.default(nodes)];
        } else if (nodes.selector) {
          var Rule = require_rule();
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          var AtRule = require_at_rule();
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new _comment.default(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        var processed = nodes.map(function(i2) {
          if (i2.parent)
            i2.parent.removeChild(i2);
          if (typeof i2.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i2.raws.before = sample.raws.before.replace(/[^\s]/g, "");
            }
          }
          i2.parent = _this;
          return i2;
        });
        return processed;
      };
      _createClass(Container2, [{
        key: "first",
        get: function get() {
          if (!this.nodes)
            return void 0;
          return this.nodes[0];
        }
        /**
         * The containers last child.
         *
         * @type {Node}
         *
         * @example
         * rule.last === rule.nodes[rule.nodes.length - 1]
         */
      }, {
        key: "last",
        get: function get() {
          if (!this.nodes)
            return void 0;
          return this.nodes[this.nodes.length - 1];
        }
      }]);
      return Container2;
    }(_node.default);
    var _default = Container;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/at-rule.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _container = _interopRequireDefault(require_container());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var AtRule = function(_Container) {
      _inheritsLoose(AtRule2, _Container);
      function AtRule2(defaults) {
        var _this;
        _this = _Container.call(this, defaults) || this;
        _this.type = "atrule";
        return _this;
      }
      var _proto = AtRule2.prototype;
      _proto.append = function append() {
        var _Container$prototype$;
        if (!this.nodes)
          this.nodes = [];
        for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
          children[_key] = arguments[_key];
        }
        return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));
      };
      _proto.prepend = function prepend() {
        var _Container$prototype$2;
        if (!this.nodes)
          this.nodes = [];
        for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          children[_key2] = arguments[_key2];
        }
        return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));
      };
      return AtRule2;
    }(_container.default);
    var _default = AtRule;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/root.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _container = _interopRequireDefault(require_container());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var Root = function(_Container) {
      _inheritsLoose(Root2, _Container);
      function Root2(defaults) {
        var _this;
        _this = _Container.call(this, defaults) || this;
        _this.type = "root";
        if (!_this.nodes)
          _this.nodes = [];
        return _this;
      }
      var _proto = Root2.prototype;
      _proto.removeChild = function removeChild(child, ignore) {
        var index2 = this.index(child);
        if (!ignore && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return _Container.prototype.removeChild.call(this, child);
      };
      _proto.normalize = function normalize(child, sample, type) {
        var nodes = _Container.prototype.normalize.call(this, child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done; ) {
              var node = _step.value;
              node.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      };
      _proto.toResult = function toResult(opts) {
        if (opts === void 0) {
          opts = {};
        }
        var LazyResult = require_lazy_result();
        var Processor = require_processor();
        var lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      };
      return Root2;
    }(_container.default);
    var _default = Root;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/parser.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _declaration = _interopRequireDefault(require_declaration());
    var _tokenize = _interopRequireDefault(require_tokenize());
    var _comment = _interopRequireDefault(require_comment());
    var _atRule = _interopRequireDefault(require_at_rule());
    var _root = _interopRequireDefault(require_root());
    var _rule = _interopRequireDefault(require_rule());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = function() {
      function Parser2(input) {
        this.input = input;
        this.root = new _root.default();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = {
          input,
          start: {
            line: 1,
            column: 1
          }
        };
      }
      var _proto = Parser2.prototype;
      _proto.createTokenizer = function createTokenizer() {
        this.tokenizer = (0, _tokenize.default)(this.input);
      };
      _proto.parse = function parse() {
        var token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      };
      _proto.comment = function comment(token) {
        var node = new _comment.default();
        this.init(node, token[2], token[3]);
        node.source.end = {
          line: token[4],
          column: token[5]
        };
        var text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node.text = "";
          node.raws.left = text;
          node.raws.right = "";
        } else {
          var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
          node.text = match[2];
          node.raws.left = match[1];
          node.raws.right = match[3];
        }
      };
      _proto.emptyRule = function emptyRule(token) {
        var node = new _rule.default();
        this.init(node, token[2], token[3]);
        node.selector = "";
        node.raws.between = "";
        this.current = node;
      };
      _proto.other = function other(start) {
        var end = false;
        var type = null;
        var colon = false;
        var bracket = null;
        var brackets = [];
        var tokens = [];
        var token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== "space" && token !== "comment")
              break;
            this.tokenizer.back(tokens.pop());
          }
          this.decl(tokens);
        } else {
          this.unknownWord(tokens);
        }
      };
      _proto.rule = function rule(tokens) {
        tokens.pop();
        var node = new _rule.default();
        this.init(node, tokens[0][2], tokens[0][3]);
        node.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node, "selector", tokens);
        this.current = node;
      };
      _proto.decl = function decl(tokens) {
        var node = new _declaration.default();
        this.init(node);
        var last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        if (last[4]) {
          node.source.end = {
            line: last[4],
            column: last[5]
          };
        } else {
          node.source.end = {
            line: last[2],
            column: last[3]
          };
        }
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node.raws.before += tokens.shift()[1];
        }
        node.source.start = {
          line: tokens[0][2],
          column: tokens[0][3]
        };
        node.prop = "";
        while (tokens.length) {
          var type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node.prop += tokens.shift()[1];
        }
        node.raws.between = "";
        var token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node.raws.between += token[1];
          }
        }
        if (node.prop[0] === "_" || node.prop[0] === "*") {
          node.raws.before += node.prop[0];
          node.prop = node.prop.slice(1);
        }
        node.raws.between += this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);
        for (var i = tokens.length - 1; i > 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === "!important") {
            node.important = true;
            var string = this.stringFrom(tokens, i);
            string = this.spacesFromEnd(tokens) + string;
            if (string !== " !important")
              node.raws.important = string;
            break;
          } else if (token[1].toLowerCase() === "important") {
            var cache = tokens.slice(0);
            var str = "";
            for (var j = i; j > 0; j--) {
              var _type = cache[j][0];
              if (str.trim().indexOf("!") === 0 && _type !== "space") {
                break;
              }
              str = cache.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node.important = true;
              node.raws.important = str;
              tokens = cache;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        this.raw(node, "value", tokens);
        if (node.value.indexOf(":") !== -1)
          this.checkMissedSemicolon(tokens);
      };
      _proto.atrule = function atrule(token) {
        var node = new _atRule.default();
        node.name = token[1].slice(1);
        if (node.name === "") {
          this.unnamedAtrule(node, token);
        }
        this.init(node, token[2], token[3]);
        var prev;
        var shift;
        var last = false;
        var open = false;
        var params = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          if (token[0] === ";") {
            node.source.end = {
              line: token[2],
              column: token[3]
            };
            this.semicolon = true;
            break;
          } else if (token[0] === "{") {
            open = true;
            break;
          } else if (token[0] === "}") {
            if (params.length > 0) {
              shift = params.length - 1;
              prev = params[shift];
              while (prev && prev[0] === "space") {
                prev = params[--shift];
              }
              if (prev) {
                node.source.end = {
                  line: prev[4],
                  column: prev[5]
                };
              }
            }
            this.end(token);
            break;
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node, "params", params);
          if (last) {
            token = params[params.length - 1];
            node.source.end = {
              line: token[4],
              column: token[5]
            };
            this.spaces = node.raws.between;
            node.raws.between = "";
          }
        } else {
          node.raws.afterName = "";
          node.params = "";
        }
        if (open) {
          node.nodes = [];
          this.current = node;
        }
      };
      _proto.end = function end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = {
            line: token[2],
            column: token[3]
          };
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      };
      _proto.endFile = function endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      };
      _proto.freeSemicolon = function freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          var prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      };
      _proto.init = function init(node, line, column) {
        this.current.push(node);
        node.source = {
          start: {
            line,
            column
          },
          input: this.input
        };
        node.raws.before = this.spaces;
        this.spaces = "";
        if (node.type !== "comment")
          this.semicolon = false;
      };
      _proto.raw = function raw(node, prop, tokens) {
        var token, type;
        var length = tokens.length;
        var value = "";
        var clean = true;
        var next, prev;
        var pattern = /^([.|#])?([\w])+/i;
        for (var i = 0; i < length; i += 1) {
          token = tokens[i];
          type = token[0];
          if (type === "comment" && node.type === "rule") {
            prev = tokens[i - 1];
            next = tokens[i + 1];
            if (prev[0] !== "space" && next[0] !== "space" && pattern.test(prev[1]) && pattern.test(next[1])) {
              value += token[1];
            } else {
              clean = false;
            }
            continue;
          }
          if (type === "comment" || type === "space" && i === length - 1) {
            clean = false;
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          var raw2 = tokens.reduce(function(all, i2) {
            return all + i2[1];
          }, "");
          node.raws[prop] = {
            value,
            raw: raw2
          };
        }
        node[prop] = value;
      };
      _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {
        var lastTokenType;
        var spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      };
      _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {
        var next;
        var spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      };
      _proto.spacesFromEnd = function spacesFromEnd(tokens) {
        var lastTokenType;
        var spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      };
      _proto.stringFrom = function stringFrom(tokens, from) {
        var result = "";
        for (var i = from; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      };
      _proto.colon = function colon(tokens) {
        var brackets = 0;
        var token, type, prev;
        for (var i = 0; i < tokens.length; i++) {
          token = tokens[i];
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i;
            }
          }
          prev = token;
        }
        return false;
      };
      _proto.unclosedBracket = function unclosedBracket(bracket) {
        throw this.input.error("Unclosed bracket", bracket[2], bracket[3]);
      };
      _proto.unknownWord = function unknownWord(tokens) {
        throw this.input.error("Unknown word", tokens[0][2], tokens[0][3]);
      };
      _proto.unexpectedClose = function unexpectedClose(token) {
        throw this.input.error("Unexpected }", token[2], token[3]);
      };
      _proto.unclosedBlock = function unclosedBlock() {
        var pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      };
      _proto.doubleColon = function doubleColon(token) {
        throw this.input.error("Double colon", token[2], token[3]);
      };
      _proto.unnamedAtrule = function unnamedAtrule(node, token) {
        throw this.input.error("At-rule without name", token[2], token[3]);
      };
      _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {
      };
      _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {
        var colon = this.colon(tokens);
        if (colon === false)
          return;
        var founded = 0;
        var token;
        for (var j = colon - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error("Missed semicolon", token[2], token[3]);
      };
      return Parser2;
    }();
    exports.default = Parser;
    module.exports = exports.default;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/previous-map.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _sourceMap = _interopRequireDefault(require_source_map());
    var _path = _interopRequireDefault(require_path());
    var _fs = _interopRequireDefault(require_fs());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = function() {
      function PreviousMap2(css, opts) {
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        var prev = opts.map ? opts.map.prev : void 0;
        var text = this.loadMap(opts.from, prev);
        if (text)
          this.text = text;
      }
      var _proto = PreviousMap2.prototype;
      _proto.consumer = function consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      };
      _proto.withContent = function withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      };
      _proto.startWith = function startWith(string, start) {
        if (!string)
          return false;
        return string.substr(0, start.length) === start;
      };
      _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {
        return sourceMapString.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
      };
      _proto.loadAnnotation = function loadAnnotation(css) {
        var annotations = css.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
        if (annotations && annotations.length > 0) {
          var lastAnnotation = annotations[annotations.length - 1];
          if (lastAnnotation) {
            this.annotation = this.getAnnotationURL(lastAnnotation);
          }
        }
      };
      _proto.decodeInline = function decodeInline(text) {
        var baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        var baseUri = /^data:application\/json;base64,/;
        var uri = "data:application/json,";
        if (this.startWith(text, uri)) {
          return decodeURIComponent(text.substr(uri.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        var encoding = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      };
      _proto.loadMap = function loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            var prevPath = prev(file);
            if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {
              return _fs.default.readFileSync(prevPath, "utf-8").toString().trim();
            } else {
              throw new Error("Unable to load previous source map: " + prevPath.toString());
            }
          } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {
            return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error("Unsupported previous source map format: " + prev.toString());
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          var map = this.annotation;
          if (file)
            map = _path.default.join(_path.default.dirname(file), map);
          this.root = _path.default.dirname(map);
          if (_fs.default.existsSync && _fs.default.existsSync(map)) {
            return _fs.default.readFileSync(map, "utf-8").toString().trim();
          } else {
            return false;
          }
        }
      };
      _proto.isMap = function isMap(map) {
        if (typeof map !== "object")
          return false;
        return typeof map.mappings === "string" || typeof map._mappings === "string";
      };
      return PreviousMap2;
    }();
    var _default = PreviousMap;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/input.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _path = _interopRequireDefault(require_path());
    var _cssSyntaxError = _interopRequireDefault(require_css_syntax_error());
    var _previousMap = _interopRequireDefault(require_previous_map());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var sequence = 0;
    var Input = function() {
      function Input2(css, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error("PostCSS received " + css + " instead of CSS string");
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (/^\w+:\/\//.test(opts.from) || _path.default.isAbsolute(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = _path.default.resolve(opts.from);
          }
        }
        var map = new _previousMap.default(this.css, opts);
        if (map.text) {
          this.map = map;
          var file = map.consumer().file;
          if (!this.file && file)
            this.file = this.mapResolve(file);
        }
        if (!this.file) {
          sequence += 1;
          this.id = "<input css " + sequence + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      var _proto = Input2.prototype;
      _proto.error = function error(message, line, column, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var result;
        var origin = this.origin(line, column);
        if (origin) {
          result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);
        } else {
          result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);
        }
        result.input = {
          line,
          column,
          source: this.css
        };
        if (this.file)
          result.input.file = this.file;
        return result;
      };
      _proto.origin = function origin(line, column) {
        if (!this.map)
          return false;
        var consumer = this.map.consumer();
        var from = consumer.originalPositionFor({
          line,
          column
        });
        if (!from.source)
          return false;
        var result = {
          file: this.mapResolve(from.source),
          line: from.line,
          column: from.column
        };
        var source = consumer.sourceContentFor(from.source);
        if (source)
          result.source = source;
        return result;
      };
      _proto.mapResolve = function mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return _path.default.resolve(this.map.consumer().sourceRoot || ".", file);
      };
      _createClass(Input2, [{
        key: "from",
        get: function get() {
          return this.file || this.id;
        }
      }]);
      return Input2;
    }();
    var _default = Input;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/parse.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _parser = _interopRequireDefault(require_parser());
    var _input = _interopRequireDefault(require_input());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(css, opts) {
      var input = new _input.default(css, opts);
      var parser = new _parser.default(input);
      try {
        parser.parse();
      } catch (e) {
        if (true) {
          if (e.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e;
      }
      return parser.root;
    }
    var _default = parse;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/lazy-result.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _mapGenerator = _interopRequireDefault(require_map_generator());
    var _stringify2 = _interopRequireDefault(require_stringify());
    var _warnOnce = _interopRequireDefault(require_warn_once());
    var _result = _interopRequireDefault(require_result());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    var LazyResult = function() {
      function LazyResult2(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        var root;
        if (typeof css === "object" && css !== null && css.type === "root") {
          root = css;
        } else if (css instanceof LazyResult2 || css instanceof _result.default) {
          root = css.root;
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          var parser = _parse.default;
          if (opts.syntax)
            parser = opts.syntax.parse;
          if (opts.parser)
            parser = opts.parser;
          if (parser.parse)
            parser = parser.parse;
          try {
            root = parser(css, opts);
          } catch (error) {
            this.error = error;
          }
        }
        this.result = new _result.default(processor, root, opts);
      }
      var _proto = LazyResult2.prototype;
      _proto.warnings = function warnings() {
        return this.sync().warnings();
      };
      _proto.toString = function toString() {
        return this.css;
      };
      _proto.then = function then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            (0, _warnOnce.default)("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      };
      _proto.catch = function _catch(onRejected) {
        return this.async().catch(onRejected);
      };
      _proto.finally = function _finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      };
      _proto.handleError = function handleError(error, plugin2) {
        try {
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin2.postcssPlugin;
            error.setMessage();
          } else if (plugin2.postcssVersion) {
            if (true) {
              var pluginName = plugin2.postcssPlugin;
              var pluginVer = plugin2.postcssVersion;
              var runtimeVer = this.result.processor.version;
              var a = pluginVer.split(".");
              var b = runtimeVer.split(".");
              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
      };
      _proto.asyncTick = function asyncTick(resolve, reject) {
        var _this = this;
        if (this.plugin >= this.processor.plugins.length) {
          this.processed = true;
          return resolve();
        }
        try {
          var plugin2 = this.processor.plugins[this.plugin];
          var promise = this.run(plugin2);
          this.plugin += 1;
          if (isPromise(promise)) {
            promise.then(function() {
              _this.asyncTick(resolve, reject);
            }).catch(function(error) {
              _this.handleError(error, plugin2);
              _this.processed = true;
              reject(error);
            });
          } else {
            this.asyncTick(resolve, reject);
          }
        } catch (error) {
          this.processed = true;
          reject(error);
        }
      };
      _proto.async = function async() {
        var _this2 = this;
        if (this.processed) {
          return new Promise(function(resolve, reject) {
            if (_this2.error) {
              reject(_this2.error);
            } else {
              resolve(_this2.stringify());
            }
          });
        }
        if (this.processing) {
          return this.processing;
        }
        this.processing = new Promise(function(resolve, reject) {
          if (_this2.error)
            return reject(_this2.error);
          _this2.plugin = 0;
          _this2.asyncTick(resolve, reject);
        }).then(function() {
          _this2.processed = true;
          return _this2.stringify();
        });
        return this.processing;
      };
      _proto.sync = function sync() {
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        if (this.error)
          throw this.error;
        for (var _iterator = _createForOfIteratorHelperLoose(this.result.processor.plugins), _step; !(_step = _iterator()).done; ) {
          var plugin2 = _step.value;
          var promise = this.run(plugin2);
          if (isPromise(promise)) {
            throw new Error("Use process(css).then(cb) to work with async plugins");
          }
        }
        return this.result;
      };
      _proto.run = function run(plugin2) {
        this.result.lastPlugin = plugin2;
        try {
          return plugin2(this.result.root, this.result);
        } catch (error) {
          this.handleError(error, plugin2);
          throw error;
        }
      };
      _proto.stringify = function stringify() {
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        var opts = this.result.opts;
        var str = _stringify2.default;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        var map = new _mapGenerator.default(str, this.result.root, this.result.opts);
        var data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      };
      _createClass(LazyResult2, [{
        key: "processor",
        get: function get() {
          return this.result.processor;
        }
        /**
         * Options from the {@link Processor#process} call.
         *
         * @type {processOptions}
         */
      }, {
        key: "opts",
        get: function get() {
          return this.result.opts;
        }
        /**
         * Processes input CSS through synchronous plugins, converts `Root`
         * to a CSS string and returns {@link Result#css}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#css
         */
      }, {
        key: "css",
        get: function get() {
          return this.stringify().css;
        }
        /**
         * An alias for the `css` property. Use it with syntaxes
         * that generate non-CSS output.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {string}
         * @see Result#content
         */
      }, {
        key: "content",
        get: function get() {
          return this.stringify().content;
        }
        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#map}.
         *
         * This property will only work with synchronous plugins.
         * If the processor contains any asynchronous plugins
         * it will throw an error. This is why this method is only
         * for debug purpose, you should always use {@link LazyResult#then}.
         *
         * @type {SourceMapGenerator}
         * @see Result#map
         */
      }, {
        key: "map",
        get: function get() {
          return this.stringify().map;
        }
        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#root}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Root}
         * @see Result#root
         */
      }, {
        key: "root",
        get: function get() {
          return this.sync().root;
        }
        /**
         * Processes input CSS through synchronous plugins
         * and returns {@link Result#messages}.
         *
         * This property will only work with synchronous plugins. If the processor
         * contains any asynchronous plugins it will throw an error.
         *
         * This is why this method is only for debug purpose,
         * you should always use {@link LazyResult#then}.
         *
         * @type {Message[]}
         * @see Result#messages
         */
      }, {
        key: "messages",
        get: function get() {
          return this.sync().messages;
        }
      }]);
      return LazyResult2;
    }();
    var _default = LazyResult;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/processor.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _lazyResult = _interopRequireDefault(require_lazy_result());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o[Symbol.iterator]();
      return it.next.bind(it);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var Processor = function() {
      function Processor2(plugins) {
        if (plugins === void 0) {
          plugins = [];
        }
        this.version = "7.0.39";
        this.plugins = this.normalize(plugins);
      }
      var _proto = Processor2.prototype;
      _proto.use = function use(plugin2) {
        this.plugins = this.plugins.concat(this.normalize([plugin2]));
        return this;
      };
      _proto.process = function(_process) {
        function process2(_x) {
          return _process.apply(this, arguments);
        }
        process2.toString = function() {
          return _process.toString();
        };
        return process2;
      }(function(css, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (this.plugins.length === 0 && opts.parser === opts.stringifier) {
          if (true) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("You did not set any plugins, parser, or stringifier. Right now, PostCSS does nothing. Pick plugins for your case on https://www.postcss.parts/ and use them in postcss.config.js.");
            }
          }
        }
        return new _lazyResult.default(this, css, opts);
      });
      _proto.normalize = function normalize(plugins) {
        var normalized = [];
        for (var _iterator = _createForOfIteratorHelperLoose(plugins), _step; !(_step = _iterator()).done; ) {
          var i = _step.value;
          if (i.postcss === true) {
            var plugin2 = i();
            throw new Error("PostCSS plugin " + plugin2.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
          }
          if (i.postcss)
            i = i.postcss;
          if (typeof i === "object" && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === "function") {
            normalized.push(i);
          } else if (typeof i === "object" && (i.parse || i.stringify)) {
            if (true) {
              throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
            }
          } else if (typeof i === "object" && i.postcssPlugin) {
            throw new Error("PostCSS plugin " + i.postcssPlugin + " requires PostCSS 8.\nMigration guide for end-users:\nhttps://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users");
          } else {
            throw new Error(i + " is not a PostCSS plugin");
          }
        }
        return normalized;
      };
      return Processor2;
    }();
    var _default = Processor;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/vendor.js
var require_vendor = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/vendor.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var vendor = {
      /**
       * Returns the vendor prefix extracted from an input string.
       *
       * @param {string} prop String with or without vendor prefix.
       *
       * @return {string} vendor prefix or empty string
       *
       * @example
       * postcss.vendor.prefix('-moz-tab-size') //=> '-moz-'
       * postcss.vendor.prefix('tab-size')      //=> ''
       */
      prefix: function prefix(prop) {
        var match = prop.match(/^(-\w+-)/);
        if (match) {
          return match[0];
        }
        return "";
      },
      /**
         * Returns the input string stripped of its vendor prefix.
         *
         * @param {string} prop String with or without vendor prefix.
         *
         * @return {string} String name without vendor prefixes.
         *
         * @example
         * postcss.vendor.unprefixed('-moz-tab-size') //=> 'tab-size'
         */
      unprefixed: function unprefixed(prop) {
        return prop.replace(/^-\w+-/, "");
      }
    };
    var _default = vendor;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/postcss-apply/node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "../../../node_modules/postcss-apply/node_modules/postcss/lib/postcss.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _declaration = _interopRequireDefault(require_declaration());
    var _processor = _interopRequireDefault(require_processor());
    var _stringify = _interopRequireDefault(require_stringify());
    var _comment = _interopRequireDefault(require_comment());
    var _atRule = _interopRequireDefault(require_at_rule());
    var _vendor = _interopRequireDefault(require_vendor());
    var _parse = _interopRequireDefault(require_parse());
    var _list = _interopRequireDefault(require_list());
    var _rule = _interopRequireDefault(require_rule());
    var _root = _interopRequireDefault(require_root());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function postcss2() {
      for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }
      if (plugins.length === 1 && Array.isArray(plugins[0])) {
        plugins = plugins[0];
      }
      return new _processor.default(plugins);
    }
    postcss2.plugin = function plugin2(name2, initializer) {
      function creator() {
        var transformer = initializer.apply(void 0, arguments);
        transformer.postcssPlugin = name2;
        transformer.postcssVersion = new _processor.default().version;
        return transformer;
      }
      var cache;
      Object.defineProperty(creator, "postcss", {
        get: function get() {
          if (!cache)
            cache = creator();
          return cache;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss2([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss2.stringify = _stringify.default;
    postcss2.parse = _parse.default;
    postcss2.vendor = _vendor.default;
    postcss2.list = _list.default;
    postcss2.comment = function(defaults) {
      return new _comment.default(defaults);
    };
    postcss2.atRule = function(defaults) {
      return new _atRule.default(defaults);
    };
    postcss2.decl = function(defaults) {
      return new _declaration.default(defaults);
    };
    postcss2.rule = function(defaults) {
      return new _rule.default(defaults);
    };
    postcss2.root = function(defaults) {
      return new _root.default(defaults);
    };
    var _default = postcss2;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// ../../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced2;
    function balanced2(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced2.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/postcss-apply/dist/index.m.js
var import_postcss = __toESM(require_postcss());
var import_balanced_match = __toESM(require_balanced_match());
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function kebabify(prop) {
  const upperToHyphen = (match, offset, string) => {
    const addDash = offset && string.charAt(offset - 1) !== "-";
    return (addDash ? "-" : "") + match.toLowerCase();
  };
  return prop.replace(/[A-Z]/g, upperToHyphen);
}
var isPlainObject = (arg) => Object.prototype.toString.call(arg) === "[object Object]";
var RE_PROP_SET = /^(--)([\w-]+)(\s*)([:]?)$/;
var Visitor = class {
  constructor(options) {
    _defineProperty(this, "cache", {});
    _defineProperty(this, "result", {});
    _defineProperty(this, "options", {});
    _defineProperty(this, "defaults", {
      preserve: false,
      sets: {}
    });
    _defineProperty(this, "prepend", () => {
      const {
        sets
      } = this.options;
      Object.keys(sets).forEach((setName) => {
        const newRule = import_postcss.default.rule({
          selector: `--${setName}`
        });
        const set = sets[setName];
        if (typeof set === "string") {
          newRule.prepend(set);
        } else if (isPlainObject(set)) {
          Object.entries(set).forEach(([prop, value]) => {
            newRule.prepend(import_postcss.default.decl({
              prop: kebabify(prop),
              value
            }));
          });
        } else {
          throw new Error(`Unrecognized set type \`${typeof set}\`, must be an object or string.`);
        }
        this.cache[setName] = newRule;
      });
    });
    _defineProperty(this, "collect", (rule) => {
      const matches = RE_PROP_SET.exec(rule.selector);
      if (!matches) {
        return;
      }
      const setName = matches[2];
      const {
        parent
      } = rule;
      if (parent.selector !== ":root") {
        rule.warn(this.result, `Custom property set ignored: not scoped to top-level \`:root\` (--${setName}${parent.type === "rule" ? ` declared in ${parent.selector}` : ""})`);
        if (parent.type === "root") {
          rule.remove();
        }
        return;
      }
      const newRule = rule.clone();
      this.cache[setName] = newRule;
      if (!this.options.preserve) {
        removeCommentBefore(rule);
        safeRemoveRule(rule);
      }
      if (!parent.nodes.length) {
        parent.remove();
      }
    });
    _defineProperty(this, "resolveNested", () => {
      Object.keys(this.cache).forEach((rule) => {
        this.cache[rule].walkAtRules("apply", (atRule) => {
          this.resolve(atRule);
          atRule.remove();
        });
      });
    });
    _defineProperty(this, "resolve", (atRule) => {
      let ancestor = atRule.parent;
      while (ancestor && ancestor.type !== "rule") {
        ancestor = ancestor.parent;
      }
      if (!ancestor) {
        atRule.warn(this.result, "The @apply rule can only be declared inside Rule type nodes.");
        atRule.remove();
        return;
      }
      if (isDefinition(atRule.parent)) {
        return;
      }
      const param = getParamValue(atRule.params);
      const matches = RE_PROP_SET.exec(param);
      if (!matches) {
        return;
      }
      const setName = matches[2];
      const {
        parent
      } = atRule;
      if (!(setName in this.cache)) {
        atRule.warn(this.result, `No custom property set declared for \`${setName}\`.`);
        return;
      }
      const newRule = this.cache[setName].clone();
      cleanIndent(newRule);
      if (this.options.preserve) {
        parent.insertBefore(atRule, newRule.nodes);
        return;
      }
      atRule.replaceWith(newRule.nodes);
    });
    this.options = _objectSpread({}, this.defaults, options);
  }
  /**
   * Prepend JS defined sets into the cache before parsing.
   * This means CSS defined sets will overrides them if they share the same name.
   */
};
function isDefinition(rule) {
  return !!rule.selector && !!RE_PROP_SET.exec(rule.selector) && rule.parent && !!rule.parent.selector && rule.parent.selector === ":root";
}
function getParamValue(param) {
  return /^\(/.test(param) ? (0, import_balanced_match.default)("(", ")", param).body : param;
}
function cleanIndent(rule) {
  rule.walkDecls((decl) => {
    if (typeof decl.raws.before === "string") {
      decl.raws.before = decl.raws.before.replace(/[^\S\n\r]{2,}/, "  ");
    }
  });
}
function safeRemoveRule(rule) {
  if (rule === rule.parent.last && rule.raws.ownSemicolon) {
    rule.parent.raws.semicolon = true;
  }
  rule.remove();
}
function removeCommentBefore(node) {
  const previousNode = node.prev();
  if (previousNode && previousNode.type === "comment") {
    previousNode.remove();
  }
}
var name = "postcss-apply";
var index = (0, import_postcss.plugin)(name, (options) => (css, result) => {
  const visitor = new Visitor(options);
  visitor.result = result;
  visitor.prepend();
  css.walkRules(visitor.collect);
  visitor.resolveNested();
  css.walkAtRules("apply", visitor.resolve);
});
var index_m_default = index;
export {
  index_m_default as default
};
//# sourceMappingURL=postcss-apply.js.map
